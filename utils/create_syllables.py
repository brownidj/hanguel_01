"""
Utility to generate data/syllables.yaml from data/consonants.yaml and data/vowels.yaml.
- Cross-joins all consonant (L) × vowel (V) to form CV syllables
- Computes Hangul syllable glyphs using the Unicode LVT formula
- Carries through vowel block_type (A/B/C/D)
- Builds a coarse IPA by concatenation (can be refined later)
- Applies optional tag overrides from data/syllable_overrides.yaml

CLI:
    python3 utils/create_syllables.py \
        --consonants data/consonants.yaml \
        --vowels data/vowels.yaml \
        --output data/syllables.yaml \
        [--overrides data/syllable_overrides.yaml]

Notes:
- No f-strings (uses str.format).
- Preserves Unicode on write (allow_unicode / ensure_ascii=False).
"""

import argparse
import os
import sys
from typing import Any, Dict, List, Optional

# Resolve defaults relative to this script, so running from any CWD works
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
DEFAULT_CONSONANTS = os.path.join(PROJECT_ROOT, "data", "consonants.yaml")
DEFAULT_VOWELS = os.path.join(PROJECT_ROOT, "data", "vowels.yaml")
DEFAULT_OUTPUT = os.path.join(PROJECT_ROOT, "data", "syllables.yaml")
DEFAULT_OVERRIDES = os.path.join(PROJECT_ROOT, "data", "syllable_overrides.yaml")

try:
    import yaml
except Exception as e:
    print("PyYAML is required. Install with: python3 -m pip install pyyaml", file=sys.stderr)
    raise

# Canonical Unicode order for Hangul Jamo indices
# 19 initial consonants (choseong, L)
CHOSEONG_ORDER = [
    u"ㄱ", u"ㄲ", u"ㄴ", u"ㄷ", u"ㄸ", u"ㄹ", u"ㅁ", u"ㅂ", u"ㅃ",
    u"ㅅ", u"ㅆ", u"ㅇ", u"ㅈ", u"ㅉ", u"ㅊ", u"ㅋ", u"ㅌ", u"ㅍ", u"ㅎ",
]

# 21 vowels (jungseong, V)
JUNGSEONG_ORDER = [
    u"ㅏ", u"ㅐ", u"ㅑ", u"ㅒ", u"ㅓ", u"ㅔ", u"ㅕ", u"ㅖ",
    u"ㅗ", u"ㅘ", u"ㅙ", u"ㅚ",
    u"ㅛ",
    u"ㅜ", u"ㅝ", u"ㅞ", u"ㅟ",
    u"ㅠ",
    u"ㅡ", u"ㅢ", u"ㅣ",
]

# 28 finals (jongseong, T) where 0 = none — not used here (CV only)
# Included for completeness
JONGSEONG_ORDER = [
    u"\0", u"ㄱ", u"ㄲ", u"ㄱㅅ", u"ㄴ", u"ㄴㅈ", u"ㄴㅎ", u"ㄷ", u"ㄹ",
    u"ㄹㄱ", u"ㄹㅁ", u"ㄹㅂ", u"ㄹㅅ", u"ㄹㅌ", u"ㄹㅍ", u"ㄹㅎ", u"ㅁ",
    u"ㅂ", u"ㅂㅅ", u"ㅅ", u"ㅆ", u"ㅇ", u"ㅈ", u"ㅊ", u"ㅋ", u"ㅌ", u"ㅍ", u"ㅎ",
]

BASE = 0xAC00  # Hangul Syllables block start
N_V = 21
N_T = 28


def build_index_maps_from_yaml(consonants: List[Dict[str, Any]], vowels: List[Dict[str, Any]]) -> (Dict[str, int], Dict[str, int]):
    """Derive L/V index maps from the provided YAML lists, using Unicode canonical
    order as the source of truth for indices. Only glyphs present in YAML are included.
    """
    # Map glyph -> canonical index
    canon_L = {g: i for i, g in enumerate(CHOSEONG_ORDER)}
    canon_V = {g: i for i, g in enumerate(JUNGSEONG_ORDER)}

    l_index: Dict[str, int] = {}
    for c in consonants:
        g = c.get("glyph")
        if not g:
            continue
        if g not in canon_L:
            raise ValueError("Consonant not in canonical choseong set: {}".format(g))
        l_index[g] = canon_L[g]

    v_index: Dict[str, int] = {}
    for v in vowels:
        g = v.get("glyph")
        if not g:
            continue
        if g not in canon_V:
            raise ValueError("Vowel not in canonical jungseong set: {}".format(g))
        v_index[g] = canon_V[g]

    return l_index, v_index


def compose_cv(consonant_glyph: str, vowel_glyph: str, l_index: Dict[str, int], v_index: Dict[str, int]) -> str:
    """Compose a Hangul CV syllable glyph using Unicode arithmetic.
    The indices used come from maps derived from the current YAML datasets
    (validated against canonical Unicode order).
    """
    try:
        l = l_index[consonant_glyph]
    except KeyError:
        raise ValueError("Unknown initial consonant glyph: {}".format(consonant_glyph))
    try:
        v = v_index[vowel_glyph]
    except KeyError:
        raise ValueError("Unknown vowel glyph: {}".format(vowel_glyph))
    t = 0  # CV only, no final
    codepoint = BASE + ((l * N_V) + v) * N_T + t
    return chr(codepoint)


def load_yaml(path: str) -> Any:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def dump_yaml(path: str, data: Any) -> None:
    with open(path, "w", encoding="utf-8") as f:
        # Auto-generated banner
        f.write("# AUTO-GENERATED FILE — DO NOT EDIT BY HAND\n")
        f.write("# Generated by utils/create_syllables.py from data/consonants.yaml and data/vowels.yaml\n")
        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)


def guess_block_type_for_vowel(vowel_entry: Dict[str, Any]) -> str:
    # Expect 'type' in vowels.yaml to be one of: A_RightBranch, B_TopBranch, C_BottomBranch, D_Horizontal
    t = vowel_entry.get("type")
    if not t:
        raise ValueError("Vowel entry is missing 'type': {}".format(vowel_entry))
    return t




def build_ipa(consonant_entry: Dict[str, Any], vowel_entry: Dict[str, Any]) -> Optional[str]:
    c_ipa = consonant_entry.get("ipa")
    v_ipa = vowel_entry.get("ipa")
    if c_ipa and v_ipa:
        return c_ipa + v_ipa
    if v_ipa:
        return v_ipa
    if c_ipa:
        return c_ipa
    return None


def build_syllables(consonants: List[Dict[str, Any]], vowels: List[Dict[str, Any]], overrides: Optional[Dict[str, str]]) -> Dict[str, Any]:
    meta = {
        "version": 1,
        "source": ["consonants.yaml", "vowels.yaml"],
        "description": "All CV syllables derived from base consonants and vowels.",
        "default_tag": "allowed",
    }
    tag_legend = {
        "allowed": "Orthographically valid and commonly attested in modern Korean.",
        "rare": "Valid but infrequent (names, onomatopoeia, archaic/loan contexts).",
        "not_used_in_spoken_language": "Avoid for teaching; not used in ordinary speech.",
        "impossible": "Orthographically invalid (should not occur for plain CV).",
    }

    items: List[Dict[str, Any]] = []

    # Index vowels by glyph for quick lookup if needed
    vowel_by_glyph = {}
    for v in vowels:
        g = v.get("glyph")
        if g:
            vowel_by_glyph[g] = v

    l_index, v_index = build_index_maps_from_yaml(consonants, vowels)

    for c in consonants:
        c_glyph = c.get("glyph")
        if not c_glyph:
            continue
        for v in vowels:
            v_glyph = v.get("glyph")
            if not v_glyph:
                continue
            try:
                glyph = compose_cv(c_glyph, v_glyph, l_index, v_index)
            except ValueError as e:
                print("[WARN] Skipping pair {} + {}: {}".format(c_glyph, v_glyph, e), file=sys.stderr)
                continue
            entry: Dict[str, Any] = {
                "glyph": glyph,
                "consonant": c_glyph,
                "vowel": v_glyph,
                "block_type": guess_block_type_for_vowel(v),
            }
            ipa = build_ipa(c, v)
            if ipa:
                entry["ipa"] = ipa
            # default tag
            tag_value = "allowed"
            if overrides and isinstance(overrides, dict):
                # overrides: {"긔": "rare", ...}
                ov = overrides.get(glyph)
                if ov:
                    tag_value = ov
            entry["tag"] = tag_value
            items.append(entry)

    data = {
        "metadata": meta,
        "tag_legend": tag_legend,
        "syllables": items,
    }
    return data


def load_overrides(path: Optional[str]) -> Optional[Dict[str, str]]:
    if not path:
        return None
    if not os.path.exists(path):
        return None
    obj = load_yaml(path)
    # allow two shapes: {overrides: {"긔": "rare"}} or {"긔": "rare"}
    if isinstance(obj, dict) and "overrides" in obj and isinstance(obj["overrides"], dict):
        return obj["overrides"]
    if isinstance(obj, dict):
        return obj  # assume flat map
    return None


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Build data/syllables.yaml from base YAMLs.")
    parser.add_argument("--consonants", default=DEFAULT_CONSONANTS, help="Path to consonants.yaml")
    parser.add_argument("--vowels", default=DEFAULT_VOWELS, help="Path to vowels.yaml")
    parser.add_argument("--output", default=DEFAULT_OUTPUT, help="Path to write syllables.yaml")
    parser.add_argument("--overrides", default=DEFAULT_OVERRIDES, help="Optional overrides file")
    args = parser.parse_args(argv)

    if not os.path.exists(args.consonants):
        print("[ERROR] Missing consonants file: {}".format(args.consonants), file=sys.stderr)
        return 1
    if not os.path.exists(args.vowels):
        print("[ERROR] Missing vowels file: {}".format(args.vowels), file=sys.stderr)
        return 1

    consonants = load_yaml(args.consonants).get("consonants", [])
    vowels = load_yaml(args.vowels).get("vowels", [])
    overrides = load_overrides(args.overrides)

    data = build_syllables(consonants, vowels, overrides)

    out_dir = os.path.dirname(args.output)
    if out_dir and not os.path.isdir(out_dir):
        os.makedirs(out_dir)

    dump_yaml(args.output, data)
    print("[OK] Wrote {} syllables to {}".format(len(data.get("syllables", [])), args.output))
    return 0


if __name__ == "__main__":
    sys.exit(main())
